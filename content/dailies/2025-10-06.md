---
id: 10-06-2025
aliases:
tags: []
---
# October 10, 2025
## Scala and Leetcode
Well, any dreams I had of reading books died when I took vacation in late August/early September. 
I went to Cologne, Amsterdam, various parts of Norway, and Prague. 

Didn't code or pick up a book once, which I consider a win.

I have settled on Scala as my hobby language, or at least the one I will practice Leetcode with.
Though it's no longer a "hot" language. There's a lot to like about it.

These are the qualities that drew me to it:
- Impure functional programming, which is more forgiving than Haskell, but offers the perks of first-class functions and immutability
- Allows for iteration and recursion, so I can model problems anyway I like (for loops have potential break statements, unlike ocaml)
- Tail recursion optimization
- Full-blown pattern matching (I was looking into Swift, but it didn't seem to have the same pattern matching power)
- A built in generic logger that can log just about anything I would need (ocaml required pre-processing).
- Lower level than TypeScript (which is not hard to do)

All in all, it just seemed like a jack of all trades that would let me model algorithms and data structures in various ways.

I was concerned about working with the JVM. In my mind, the ideal hobby language was going to be extremely light. Something I could script with, or piece together large projects.
With scala-cli and mill, it seems I can do that in a lightweight way.

I haven't perfected my LSP setup with Neovim, but it works well enough.

These are some qualities that have become apparent to me as I have worked with it more, which I enjoy:
- It's a deep language where you can do something a thousand different ways. This may not be good for prod, or large teams, but it allows expressiveness and style, which can make hobby work fun
- As mentioned above, scala-cli, which allows me to run lightweight scripts
- The type system feels much more like that which I am used to. It doesn't infer as much as Haskell/Ocaml or anything with Hindler Milner, but I don't think that's a terrible thing. You need to be more explicit, which I find valuable for large scale applications. The type syntax for returns and such seems overly "Mathy" for my tastes. While the type system is definitely elegant, it's overly abstracted past the point of practicality.
- Chaining operations doesn't seem to be completely mandatory for idiomatic Scala, chaining lost its luster when I was messing around with Haskell.
- Everything as objects. I didn't realize how ergonomic this felt. It makes the language feels very discoverable, and also shortens code.
