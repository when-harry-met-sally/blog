---
id: goals
aliases:
  - Goals
tags: []
title: Goals
---
I hope to get a feel for a broad variety of languages that embrace different paradigms or ideas. The following interest me because they seem to be diverse and well-liked.

### Languages
- Haskell
- Rust
- Elixir
- Prolog (or some logic language)
- Clojure (or some language with s-expressions)

So far, I have experienced a little bit of Rust and Haskell.
My experience with Rust coincided with my first taste of [[vim]]. I struggled on both fronts. Ownership beat me over the head until I gave up. This was before I fully embraced LLM's, which likely would have been great assistance. 

I started to follow the book "Crafting Compilers" and build an interpreter as my first big Haskell project. It went OK, but I am taking a break after being stumped by closures. It seemed to require a level of mutation not easily mimicked by Haskell in a functional way.

I have no experience with elixir and know little about it except that it seems to be related to Erlang.

I know little of Prolog except that it is a logic language, which is apparently very different from a general programming language.

Clojure follows the principle of code-as-data, which I don't fully understand, but know there's something to that. The idea of a genetic algorithm + data-as-code seems really cool.

### Operating Systems
I tinkered with Linux for the first time last year. I had absolutely no experience with it as a personal computer.

I bought a "ThinkPad X1 Yoga Gen 8 Intel" and threw Arch Linux on it. 

I was really impressed by the bare bones and customizable aspects of Arch. I loved the idea of having a computer that was tailored exactly to what you need.

I then heard about NixOS, with its promises of perfect reproducibility. The purely functional nature of it. I knew something was there, but didn't fully understand it. And still don't. I tried to adopt it, but gave up. A few days ago however, I wiped my desktop computer and took the plunge. Many suggest using a virtual machine before committing. But I'm not that type of guy.

So, one of my top priorities right now is to really understand Nix.

The question of "why?", is interesting though. What does Nix offer me that Arch couldn't? Does perfect reproducibility mean anything when you seldom swap computers?

I'm not sure, and I'm not sure I made the right choice. But I feel like you can't really error when you are doing something for the sake of learning.

The idea of Nix, that the average operating systems is fundamentally flawed and that things can be done functionally, is bold.

I have a feeling that this will be my 'forever home' for an OS. I just need to get over the hump.
